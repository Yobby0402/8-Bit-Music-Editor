# 示波器可视化功能设计

## 功能概述

实现一个类似示波器的波形可视化功能，将不同音轨显示为不同通道的波形，波形从左向右滚动，最终到达右侧的"蜂鸣器"并发出声音。

## 可行性分析

### ✅ 技术可行性

1. **音频数据获取**
   - 已有 `AudioEngine` 可以生成音频波形数据（numpy数组）
   - 可以实时获取每个音轨的音频数据
   - 支持按时间片段获取音频数据

2. **可视化技术**
   - 可以使用 PyQt5 的 `QPainter` 绘制波形
   - 也可以使用 pygame 的 Surface 绘制（但需要与 PyQt5 集成）
   - 推荐使用 PyQt5，因为主界面已经是 PyQt5

3. **实时更新**
   - 可以在播放时通过定时器实时更新波形显示
   - 可以从小块音频缓冲区获取数据（例如每50ms更新一次）

4. **多通道显示**
   - 可以将不同音轨显示在不同的"通道"上
   - 每个通道可以有不同的颜色和位置

5. **滚动效果**
   - 可以实现波形从左向右滚动
   - 使用双缓冲技术避免闪烁

### 🎯 设计思路

1. **创建 OscilloscopeWidget**
   - 继承自 `QWidget`
   - 使用 `paintEvent` 绘制波形
   - 使用定时器实时更新

2. **波形数据获取**
   - 在播放时，实时获取每个音轨的音频数据
   - 可以获取当前播放位置前后一小段时间的音频数据
   - 对音频数据进行采样和缩放，适合显示

3. **多通道显示**
   - 每个音轨对应一个通道
   - 通道垂直排列，每个通道占据一定高度
   - 不同通道使用不同颜色区分

4. **滚动效果**
   - 波形从左向右滚动
   - 新数据从左侧进入，旧数据从右侧移出
   - 在右侧显示"蜂鸣器"（可以是一个可视化元素）

5. **与现有系统集成**
   - 作为可选的可视化模式
   - 可以通过菜单或按钮切换显示模式
   - 与网格序列编辑器并行存在

## 实现方案

### 1. 架构设计

```
ui/
  ├── oscilloscope_widget.py  # 示波器可视化组件
  └── main_window.py           # 主窗口（添加切换功能）
```

### 2. 核心功能

#### OscilloscopeWidget
- `update_audio_data(tracks, current_time)`: 更新音频数据
- `paintEvent()`: 绘制波形
- `start_visualization()`: 开始可视化
- `stop_visualization()`: 停止可视化

#### 数据获取策略
- 在播放时，实时获取每个音轨的音频数据
- 获取当前播放位置前后一小段时间的音频数据（例如前后0.1秒）
- 对音频数据进行采样（例如每像素对应多个采样点）
- 计算波形的最大值和最小值，用于绘制

#### 绘制策略
- 使用 `QPainter` 绘制波形
- 每个通道绘制一条波形线
- 实现滚动效果：新数据从左侧进入，旧数据从右侧移出
- 在右侧绘制"蜂鸣器"（可以是一个圆形或矩形，表示音频输出点）

### 3. 性能优化

1. **数据采样**
   - 不需要显示所有采样点，可以按比例采样
   - 例如：每10个采样点取一个，或按显示宽度采样

2. **双缓冲**
   - 使用 `QWidget.setAttribute(Qt.WA_OpaquePaintEvent)` 优化绘制
   - 避免不必要的重绘

3. **更新频率**
   - 不需要每帧都更新，可以每50ms更新一次
   - 使用 `QTimer` 控制更新频率

### 4. 用户体验

1. **切换模式**
   - 在菜单或工具栏添加"示波器视图"选项
   - 可以在网格序列编辑器和示波器视图之间切换
   - 或者同时显示两个视图（使用QSplitter）

2. **视觉设计**
   - 使用深色背景（类似真实示波器）
   - 不同通道使用不同颜色（可以对应音轨颜色）
   - 添加网格线辅助观察
   - 在右侧显示"蜂鸣器"图标

3. **交互功能**
   - 可以调整时间窗口（显示多长时间的数据）
   - 可以调整垂直缩放（波形的幅度）
   - 可以暂停/继续可视化

## 实现步骤

1. **创建 OscilloscopeWidget 基础框架**
   - 创建 `ui/oscilloscope_widget.py`
   - 实现基本的绘制功能
   - 实现定时器更新

2. **实现音频数据获取**
   - 在播放时获取音频数据
   - 实现数据采样和缩放
   - 实现滚动缓冲区

3. **实现波形绘制**
   - 实现多通道波形绘制
   - 实现滚动效果
   - 实现"蜂鸣器"可视化

4. **集成到主窗口**
   - 添加切换功能
   - 实现与播放系统的同步

5. **优化和美化**
   - 优化性能
   - 美化界面
   - 添加交互功能

## 技术细节

### 音频数据获取

```python
def get_audio_snippet(self, track, current_time, window_size=0.1):
    """获取当前时间点前后一小段时间的音频数据"""
    start_time = max(0, current_time - window_size / 2)
    end_time = current_time + window_size / 2
    audio = self.audio_engine.generate_track_audio(
        track, start_time, end_time
    )
    return audio
```

### 波形绘制

```python
def paintEvent(self, event):
    painter = QPainter(self)
    # 绘制背景
    # 绘制网格
    # 绘制每个通道的波形
    # 绘制"蜂鸣器"
```

### 滚动效果

```python
# 使用循环缓冲区存储波形数据
self.waveform_buffer = collections.deque(maxlen=buffer_size)
# 新数据从左侧进入
self.waveform_buffer.appendleft(new_data)
# 绘制时从缓冲区读取
```

## 预期效果

- 类似真实示波器的多通道波形显示
- 波形从左向右滚动，实时反映音频播放状态
- 不同音轨显示为不同颜色的波形
- 在右侧显示"蜂鸣器"，表示音频输出点
- 与现有网格序列编辑器并行存在，可以切换或同时显示

## 注意事项

1. **性能考虑**
   - 实时音频数据获取和绘制可能消耗较多资源
   - 需要优化数据采样和绘制频率

2. **同步问题**
   - 需要确保可视化与播放状态同步
   - 需要考虑播放暂停、停止等情况

3. **用户体验**
   - 可视化应该是可选的，不影响现有功能
   - 应该提供清晰的切换方式

