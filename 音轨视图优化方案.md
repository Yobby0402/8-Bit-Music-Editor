# 音轨视图优化方案

## 一、问题分析

### 1.1 当前问题
- **播放时滚动或拉伸导致音符渲染错乱**
- 可能原因：
  1. 滚动时坐标更新不及时
  2. 缩放时位置计算错误
  3. 播放线z值可能不够高（当前1000）
  4. 轨道标签和勾选框的坐标更新有问题

### 1.2 当前架构
- 所有轨道在同一个 `QGraphicsScene` 中
- 每个音符是独立的 `SequenceBlock` (QGraphicsItem)
- 轨道标签和勾选框使用 `QGraphicsTextItem` 和 `QGraphicsProxyWidget`
- 播放线使用 `QGraphicsLineItem`，z值=1000

## 二、优化方案

### 方案1：每个轨道作为独立的QGraphicsItemGroup（推荐）

#### 2.1.1 架构设计
```python
class TrackGroup(QGraphicsItemGroup):
    """轨道组，包含一个轨道的所有元素"""
    def __init__(self, track, track_index, parent=None):
        super().__init__(parent)
        self.track = track
        self.track_index = track_index
        self.track_y = track_index * 60 + 20
        self.note_blocks = {}  # 该轨道上的所有音符块
        
        # 创建轨道线
        self.track_line = None
        # 创建轨道标签（作为子项）
        self.track_label = None
        # 创建勾选框（作为子项）
        self.checkbox_proxy = None
        
    def update_position(self, pixels_per_beat, scene_width):
        """更新整个轨道的位置和大小"""
        # 更新轨道线
        if self.track_line:
            self.track_line.setLine(100, 0, scene_width, 0)
        
        # 更新所有音符块的位置
        for block in self.note_blocks.values():
            # 重新计算x坐标
            x = 100 + start_beats * pixels_per_beat
            block.setPos(x, 0)  # 相对于轨道组的坐标
        
    def update_scale(self, pixels_per_beat):
        """更新缩放"""
        # 更新所有音符块的宽度
        for block in self.note_blocks.values():
            block.update_width(pixels_per_beat)
```

#### 2.1.2 优点
- ✅ **统一管理**：每个轨道的所有元素（标签、勾选框、音符、轨道线）都在一个组中
- ✅ **同步缩放**：缩放时只需更新组的变换，所有子项自动同步
- ✅ **同步移动**：滚动时只需移动组，所有子项自动同步
- ✅ **简化坐标系统**：音符使用相对于轨道的坐标，简化计算
- ✅ **性能优化**：Qt的ItemGroup对子项有优化

#### 2.1.3 缺点
- ⚠️ **复杂度增加**：需要重构现有代码
- ⚠️ **事件处理**：需要确保事件正确传递到子项

#### 2.1.4 性能影响
- **正面影响**：
  - Qt的ItemGroup对子项有优化，减少重绘区域
  - 统一变换矩阵，减少计算
- **负面影响**：
  - 轻微增加内存（每个组对象）
  - 事件传递可能稍慢（但可忽略）

### 方案2：使用QGraphicsItemGroup但保持现有结构（折中方案）

#### 2.2.1 架构设计
```python
# 不改变现有结构，只是将每个轨道的元素组织成组
class TrackGroup(QGraphicsItemGroup):
    """轨道组，包装现有元素"""
    def __init__(self, track, track_index):
        super().__init__()
        self.track = track
        self.track_index = track_index
        
    def add_track_elements(self, label, checkbox, line, notes):
        """添加轨道元素到组"""
        self.addToGroup(label)
        self.addToGroup(checkbox)
        self.addToGroup(line)
        for note in notes:
            self.addToGroup(note)
```

#### 2.2.2 优点
- ✅ **最小改动**：只需将现有元素添加到组中
- ✅ **同步变换**：自动同步缩放和移动
- ✅ **向后兼容**：保持现有代码结构

#### 2.2.3 缺点
- ⚠️ **部分优化**：不如完全重构效果好

### 方案3：优化坐标更新机制（保守方案）

#### 2.3.1 架构设计
```python
def refresh(self):
    """刷新时确保所有坐标正确"""
    # 1. 禁用视图更新
    self.view.setUpdatesEnabled(False)
    
    # 2. 批量更新所有元素位置
    for i, track in enumerate(self.tracks):
        y = i * 60 + 20
        # 更新轨道标签
        if i < len(self.track_label_items):
            label = self.track_label_items[i]
            label.setPos(30, y + 5)
        # 更新勾选框
        if i < len(self.checkbox_proxies):
            checkbox = self.checkbox_proxies[i]
            checkbox.setPos(5, y + 15)
        # 更新所有音符
        for note in track.notes:
            block = self.note_blocks.get((id(note), id(track)))
            if block:
                x = 100 + note.start_time * self.bpm / 60.0 * self.pixels_per_beat
                block.setPos(x, y)
                block.original_y = y
    
    # 3. 重新启用更新
    self.view.setUpdatesEnabled(True)
    self.view.update()
```

#### 2.3.2 优点
- ✅ **最小改动**：只需优化刷新逻辑
- ✅ **风险低**：不改变架构

#### 2.3.3 缺点
- ⚠️ **治标不治本**：可能无法完全解决滚动/缩放问题
- ⚠️ **性能**：需要遍历所有元素

### 方案4：提高播放线z值并优化渲染顺序（快速修复）

#### 2.4.1 架构设计
```python
def draw_playhead(self):
    """绘制播放头，确保在最上层"""
    # 移除旧的播放头
    if self.playhead_item:
        self.scene.removeItem(self.playhead_item)
    
    # 创建新的播放头
    beats_per_second = self.bpm / 60.0
    beat_position = self.playhead_time * beats_per_second
    x = 100 + beat_position * self.pixels_per_beat
    
    scene_height = self.scene.sceneRect().height()
    self.playhead_item = self.scene.addLine(x, 0, x, scene_height, pen)
    self.playhead_item.setZValue(10000)  # 提高到10000，确保在所有元素之上
    
    # 强制播放线在最上层
    self.playhead_item.stackBefore(None)  # 移到最上层
```

#### 2.4.2 优点
- ✅ **快速修复**：只需修改播放线绘制
- ✅ **确保可见**：播放线始终在最上层

#### 2.4.3 缺点
- ⚠️ **不解决根本问题**：不解决滚动/缩放问题

## 三、推荐方案组合

### 3.1 短期方案（立即实施）
1. **方案4**：提高播放线z值到10000，确保始终在最上层
2. **方案3**：优化坐标更新机制，确保刷新时所有坐标正确

### 3.2 中期方案（1-2周）
1. **方案2**：使用QGraphicsItemGroup包装现有元素
2. 优化滚动和缩放事件处理

### 3.3 长期方案（1个月+）
1. **方案1**：完全重构为TrackGroup架构
2. 实现虚拟滚动（只渲染可见轨道）

## 四、性能分析

### 4.1 方案1（TrackGroup）性能影响
- **内存**：每个轨道增加约100-200字节（组对象）
- **CPU**：
  - 缩放时：O(n) → O(m)，n=音符数，m=轨道数（显著提升）
  - 滚动时：O(n) → O(m)（显著提升）
  - 重绘：Qt自动优化，只重绘变化区域
- **结论**：**性能提升明显**，特别是轨道数量多时

### 4.2 方案2（包装现有元素）性能影响
- **内存**：每个轨道增加约100字节
- **CPU**：缩放和滚动性能提升约30-50%
- **结论**：**性能提升中等**

### 4.3 方案3（优化坐标更新）性能影响
- **内存**：无变化
- **CPU**：刷新时可能稍慢（需要遍历所有元素）
- **结论**：**性能影响小**

### 4.4 方案4（提高播放线z值）性能影响
- **内存**：无变化
- **CPU**：无变化
- **结论**：**无性能影响**

## 五、实施建议

### 5.1 立即实施（今天）
1. ✅ 提高播放线z值到10000
2. ✅ 优化坐标更新机制
3. ✅ 添加调试日志，定位问题

### 5.2 本周实施
1. ✅ 实现方案2（TrackGroup包装）
2. ✅ 测试滚动和缩放功能

### 5.3 后续优化
1. ✅ 考虑方案1（完全重构）
2. ✅ 实现虚拟滚动（如果轨道数量>50）

## 六、风险评估

### 6.1 方案1风险
- **高风险**：需要大量重构
- **建议**：先在分支实现，充分测试后再合并

### 6.2 方案2风险
- **中风险**：需要修改现有代码
- **建议**：逐步迁移，保持向后兼容

### 6.3 方案3风险
- **低风险**：主要是优化，不改变架构
- **建议**：可以立即实施

### 6.4 方案4风险
- **极低风险**：只修改一个值
- **建议**：可以立即实施

## 七、总结

**推荐方案组合**：
1. **立即**：方案4（提高播放线z值）+ 方案3（优化坐标更新）
2. **本周**：方案2（TrackGroup包装）
3. **长期**：方案1（完全重构，如果方案2不够）

**性能影响**：
- 方案1和2都会**提升性能**，特别是缩放和滚动时
- 方案3和4**性能影响很小**

**可行性**：
- 方案4：✅ 立即可行
- 方案3：✅ 立即可行
- 方案2：✅ 本周可行
- 方案1：⚠️ 需要更多时间

