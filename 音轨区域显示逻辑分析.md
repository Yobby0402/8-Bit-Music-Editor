# 音轨区域显示逻辑分析

## 一、当前架构

### 1.1 布局结构
```
MainWindow
└── main_layout (QVBoxLayout)
    ├── note_selection_area (QWidget) - 上方统一编辑器，拉伸因子1
    └── track_area (QWidget) - 下方音轨区域，拉伸因子1
        └── track_area_layout (QVBoxLayout)
            ├── playback_control_area (QWidget) - 播放控制
            └── sequence_widget (GridSequenceWidget) - 序列编辑器，拉伸因子1
                └── layout (QVBoxLayout)
                    ├── track_selection_layout (QHBoxLayout) - 按钮行
                    ├── timeline (TimelineWidget) - 时间轴
                    └── view (QGraphicsView) - 图形视图，拉伸因子1
                        └── scene (QGraphicsScene) - 场景，包含所有音轨
```

### 1.2 关键组件

**GridSequenceWidget**:
- 使用 `QVBoxLayout` 垂直布局
- 包含按钮行、时间轴、`QGraphicsView`
- 大小策略：`QSizePolicy.Expanding, QSizePolicy.Expanding`

**QGraphicsView**:
- 大小策略：`QSizePolicy.Expanding, QSizePolicy.Expanding`
- 最小高度：200px
- 滚动条策略：
  - 横向：`ScrollBarAlwaysOn`
  - 纵向：`ScrollBarAsNeeded`

**QGraphicsScene**:
- 场景高度：`len(self.tracks) * 60 + 100`
- 场景宽度：`max(2000, max_x)`（根据音符位置计算）

## 二、轨道绘制逻辑

### 2.1 轨道Y坐标计算
```python
track_spacing = 60  # 每个轨道间距60px
y = i * track_spacing + 20  # 第i个轨道的Y坐标
```

### 2.2 场景高度计算
```python
if self.tracks:
    scene_height = len(self.tracks) * 60 + 100
else:
    scene_height = 200
```

### 2.3 轨道元素位置
- **轨道标签**：`(30, y + 5)` - 场景坐标，滚动时转换为视口坐标
- **勾选框**：`(5, y + 15)` - 场景坐标，滚动时转换为视口坐标
- **轨道线**：从 `(100, y)` 到 `(scene_width, y)`
- **音符块**：`(x, y)` - x根据时间计算，y使用轨道Y坐标

## 三、潜在问题分析

### 3.1 问题1：轨道可能重叠
**原因**：
- 如果场景高度计算错误，或者视图高度小于场景高度但没有正确显示滚动条
- 轨道Y坐标计算可能有问题

**检查点**：
- `scene_height` 是否正确计算
- `view` 的高度是否足够显示所有轨道
- 滚动条是否正确显示

### 3.2 问题2：视图高度固定
**原因**：
- `view.setMinimumHeight(200)` 设置了最小高度200px
- 如果轨道数量多，场景高度会很大，但视图高度可能被限制
- 应该通过滚动条显示，但可能滚动条没有正确工作

**检查点**：
- 视图是否设置了最大高度（不应该设置）
- 滚动条是否正确启用
- 场景高度是否大于视图高度

### 3.3 问题3：场景坐标与视口坐标混淆
**原因**：
- 轨道标签和勾选框使用场景坐标，但在滚动时需要转换为视口坐标
- `on_horizontal_scroll` 和 `on_vertical_scroll` 方法负责更新位置
- 如果这些方法有问题，可能导致元素位置错误

**检查点**：
- `on_horizontal_scroll` 和 `on_vertical_scroll` 是否正确实现
- 滚动时元素位置是否正确更新

### 3.4 问题4：布局策略问题
**原因**：
- `GridSequenceWidget` 和 `view` 都设置了 `Expanding` 大小策略
- 如果父容器高度固定，可能导致视图无法正确显示

**检查点**：
- 父容器的高度策略
- 视图是否能够正确拉伸

## 四、优化方案

### 4.1 方案1：确保场景高度正确
```python
# 确保场景高度至少能容纳所有轨道
track_spacing = 60
min_scene_height = len(self.tracks) * track_spacing + 100
current_scene_height = self.scene.sceneRect().height()
if current_scene_height < min_scene_height:
    self.scene.setSceneRect(0, 0, scene_width, min_scene_height)
```

### 4.2 方案2：确保视图可以滚动
```python
# 确保视图没有最大高度限制
self.view.setMaximumHeight(16777215)  # Qt的最大值
# 或者不设置最大高度

# 确保滚动条正确显示
if scene_height > view_height:
    self.view.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
else:
    self.view.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
```

### 4.3 方案3：修复轨道位置计算
```python
# 确保每个轨道的Y坐标正确
for i, track in enumerate(self.tracks):
    y = i * track_spacing + 20
    # 验证y坐标在场景范围内
    assert y >= 0 and y < scene_height, f"轨道Y坐标超出场景范围: y={y}, scene_height={scene_height}"
```

### 4.4 方案4：使用QScrollArea包装（备选）
如果 `QGraphicsView` 的滚动有问题，可以考虑使用 `QScrollArea` 包装：
```python
scroll_area = QScrollArea()
scroll_area.setWidget(self.view)
scroll_area.setWidgetResizable(True)
layout.addWidget(scroll_area, 1)
```

### 4.5 方案5：调试信息输出
添加调试信息，帮助定位问题：
```python
def refresh(self):
    print(f"轨道数量: {len(self.tracks)}")
    print(f"场景高度: {self.scene.sceneRect().height()}")
    print(f"视图高度: {self.view.height()}")
    print(f"视图视口高度: {self.view.viewport().height()}")
    for i, track in enumerate(self.tracks):
        y = i * 60 + 20
        print(f"轨道 {i} ({track.name}): y={y}")
```

## 五、推荐优化方案

### 5.1 立即修复
1. **确保场景高度正确**：在 `refresh()` 方法中，确保场景高度至少能容纳所有轨道
2. **移除视图高度限制**：确保视图没有最大高度限制
3. **验证滚动条**：确保垂直滚动条在需要时正确显示

### 5.2 长期优化
1. **重构布局**：考虑使用更简单的布局结构
2. **性能优化**：如果轨道数量很多，考虑虚拟滚动（只渲染可见轨道）
3. **用户体验**：添加轨道折叠/展开功能

## 六、调试步骤

1. **检查场景高度**：打印场景高度和轨道数量
2. **检查视图高度**：打印视图高度和视口高度
3. **检查轨道位置**：打印每个轨道的Y坐标
4. **检查滚动条**：检查滚动条是否显示，是否可用
5. **检查布局**：检查父容器的布局和大小策略

