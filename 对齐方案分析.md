# 音轨名称对齐问题 - 方案详细分析

## 当前实现状态
- 音轨名称通过 `QGraphicsTextItem` 在 `QGraphicsScene` 中渲染
- 位置：x=30, y=5（相对于TrackGroup）
- TrackGroup位置：y = track_index * 60 + 20
- 每个轨道高度：60px
- **目前没有左侧独立的音轨名称列表**

---

## 方案1：统一使用 QGraphicsScene 渲染音轨名称（当前方案，但需要改进）

### 实现路径
1. **保持现状**：音轨名称继续在场景中渲染
2. **添加固定左侧区域**：
   - 在场景左侧（x=0到x=100）绘制固定背景
   - 音轨名称、复选框都在这个固定区域内
   - 使用 `QGraphicsRectItem` 绘制背景
   - 使用 `QGraphicsTextItem` 绘制名称
   - 使用 `QGraphicsProxyWidget` 放置复选框
3. **滚动处理**：
   - 水平滚动时，固定区域不滚动（通过视图变换实现）
   - 垂直滚动时，固定区域与内容区域同步滚动

### 技术细节
```python
# 伪代码示例
class FixedLeftArea(QGraphicsItem):
    def __init__(self, width=100):
        self.width = width
        # 背景矩形
        self.background = QGraphicsRectItem(0, 0, width, scene_height)
        # 音轨名称列表
        self.track_labels = []
    
    def update_tracks(self, tracks):
        for i, track in enumerate(tracks):
            y = i * 60 + 20
            # 创建标签
            label = QGraphicsTextItem(track.name)
            label.setPos(30, y + 5)
            # 创建复选框
            checkbox = QCheckBox()
            proxy = QGraphicsProxyWidget()
            proxy.setWidget(checkbox)
            proxy.setPos(5, y + 15)
```

### 优点
- ✅ **对齐精确**：同一坐标系，天然对齐
- ✅ **滚动自动同步**：垂直滚动天然同步
- ✅ **实现相对简单**：不需要手动同步滚动
- ✅ **性能好**：QGraphicsScene优化良好

### 缺点
- ❌ **水平滚动处理复杂**：需要实现"固定左侧，滚动右侧"的效果
  - 方案A：使用两个视图（左侧固定视图 + 右侧滚动视图）
  - 方案B：使用视图变换，在绘制时偏移固定区域
  - 方案C：使用 `QGraphicsView.setSceneRect` 和自定义绘制
- ❌ **交互处理**：点击、悬停等事件需要特殊处理
- ❌ **复选框交互**：`QGraphicsProxyWidget` 在某些情况下可能有性能问题

### 风险
1. **高风险**：水平滚动时固定左侧区域的实现
   - Qt没有原生支持"部分固定"的滚动
   - 需要自定义 `QGraphicsView` 或使用两个视图
   - 两个视图需要精确同步垂直滚动
2. **中风险**：复选框交互问题
   - `QGraphicsProxyWidget` 在某些Qt版本可能有渲染问题
   - 需要测试各种场景
3. **低风险**：性能问题
   - 如果轨道数量很多（>100），可能需要虚拟化

### 实现复杂度：⭐⭐⭐（中等）
- 需要自定义视图或使用两个视图
- 需要处理滚动同步
- 需要处理事件传递

---

## 方案2：使用 QSplitter + 同步滚动

### 实现路径
1. **布局结构**：
   ```
   QSplitter (水平)
   ├── QScrollArea (左侧，音轨名称列表)
   │   └── QWidget (容器)
   │       └── QVBoxLayout
   │           ├── 占位Widget (高度20px，对应顶部偏移)
   │           ├── TrackItemWidget (高度60px) × N
   │           └── 占位Widget (高度=剩余空间，确保底部对齐)
   └── QGraphicsView (右侧，音轨序列区域)
   ```

2. **同步滚动实现**：
   ```python
   def on_left_scroll(value):
       # 左侧滚动时，同步右侧
       right_scrollbar = self.view.verticalScrollBar()
       right_scrollbar.setValue(value)
   
   def on_right_scroll(value):
       # 右侧滚动时，同步左侧
       left_scrollbar = self.track_list_scroll.verticalScrollBar()
       left_scrollbar.setValue(value)
   ```

3. **轨道高度一致性**：
   - 左侧：每个 `TrackItemWidget` 固定高度 60px
   - 右侧：每个轨道高度 60px（y = i * 60 + 20）
   - 顶部占位：20px（对应右侧的顶部偏移）

### 技术细节
```python
# 左侧列表项
class TrackListItem(QWidget):
    def __init__(self, track, parent=None):
        super().__init__(parent)
        self.setFixedHeight(60)  # 固定高度
        layout = QHBoxLayout()
        # 复选框
        checkbox = QCheckBox()
        # 音轨名称
        label = QLabel(track.name)
        layout.addWidget(checkbox)
        layout.addWidget(label)
        self.setLayout(layout)
```

### 优点
- ✅ **实现直观**：使用标准Qt组件
- ✅ **交互简单**：复选框、标签都是标准Widget
- ✅ **布局灵活**：可以轻松添加其他控件（如音量滑块等）
- ✅ **维护性好**：代码结构清晰

### 缺点
- ❌ **滚动同步复杂**：需要精确同步两个滚动条
  - 滚动条范围可能不同（内容高度不同）
  - 滚动条步长可能不同
  - 需要处理滚动条可见性
- ❌ **对齐精度问题**：
  - 两个独立的滚动区域，可能出现1-2px的偏差
  - 滚动条宽度不同可能导致视觉偏差
  - 需要精确计算滚动条范围
- ❌ **性能问题**：
  - 如果轨道数量很多，左侧列表需要渲染所有项
  - 可以考虑虚拟化，但会增加复杂度

### 风险
1. **高风险**：滚动同步精度
   - 两个滚动条的范围必须完全一致
   - 滚动条的单位（像素）必须一致
   - 需要处理滚动条可见性变化
   - 可能出现"滚动不同步"的bug
2. **中风险**：对齐精度
   - 即使滚动同步，也可能出现1-2px偏差
   - 需要精确计算顶部占位高度
   - 需要确保轨道高度完全一致
3. **低风险**：性能
   - 大量轨道时可能需要虚拟化
   - 但通常不会超过100个轨道

### 实现复杂度：⭐⭐⭐（中等）
- 需要实现滚动同步逻辑
- 需要精确计算滚动条范围
- 需要处理边界情况

---

## 方案3：固定左侧列表，右侧可滚动

### 实现路径
1. **布局结构**：
   ```
   QHBoxLayout
   ├── QWidget (左侧，固定，不滚动)
   │   └── QVBoxLayout
   │       ├── 占位Widget (高度20px)
   │       ├── TrackItemWidget (高度60px) × N
   │       └── addStretch() (底部对齐)
   └── QGraphicsView (右侧，可滚动)
   ```

2. **关键点**：
   - 左侧列表**不滚动**，始终显示所有轨道
   - 右侧视图可以垂直滚动
   - 左侧列表的高度 = 右侧视图的可见高度
   - 当右侧滚动时，左侧列表不滚动，但可以通过"高亮"显示当前可见的轨道

### 技术细节
```python
# 左侧列表不滚动，但可以高亮当前可见轨道
def on_right_scroll(value):
    # 计算当前可见的轨道范围
    visible_top = value
    visible_bottom = value + self.view.height()
    
    # 高亮可见的轨道
    for i, track_item in enumerate(self.track_items):
        track_y = i * 60 + 20
        if visible_top <= track_y < visible_bottom:
            track_item.set_highlighted(True)
        else:
            track_item.set_highlighted(False)
```

### 优点
- ✅ **实现最简单**：不需要滚动同步
- ✅ **对齐精确**：左侧不滚动，位置固定
- ✅ **交互直观**：用户可以看到所有轨道名称
- ✅ **性能好**：不需要处理滚动同步

### 缺点
- ❌ **空间占用**：如果轨道很多，左侧列表会很长
  - 解决方案：限制左侧列表最大高度，超出部分不显示
- ❌ **滚动体验**：右侧滚动时，左侧不滚动，可能造成"轨道名称和内容分离"的视觉问题
  - 解决方案：高亮当前可见的轨道
- ❌ **大量轨道时**：如果轨道数量>20，左侧列表会占用大量垂直空间
  - 解决方案：使用虚拟化或限制显示数量

### 风险
1. **中风险**：大量轨道时的空间问题
   - 如果轨道数量很多（>50），左侧列表会很长
   - 需要限制最大高度或使用虚拟化
2. **低风险**：滚动体验
   - 右侧滚动时，左侧不滚动，可能造成视觉分离
   - 但可以通过高亮来缓解
3. **低风险**：对齐精度
   - 只要确保轨道高度一致，对齐应该没问题

### 实现复杂度：⭐⭐（简单）
- 不需要滚动同步
- 只需要确保轨道高度一致
- 可能需要处理大量轨道的情况

---

## 方案4：使用 QTableWidget 或 QListWidget（不推荐）

### 实现路径
使用 `QTableWidget` 或 `QListWidget` 作为左侧列表，但需要：
- 自定义item高度（60px）
- 同步滚动
- 处理对齐

### 缺点
- ❌ 灵活性差
- ❌ 自定义困难
- ❌ 性能可能不如自定义Widget

### 不推荐原因
- 对于这种场景，自定义Widget更灵活
- QTableWidget/QListWidget的虚拟化可能不够灵活

---

## 推荐方案对比

| 方案 | 实现复杂度 | 对齐精度 | 滚动体验 | 性能 | 推荐度 |
|------|-----------|---------|---------|------|--------|
| 方案1 | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| 方案2 | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| 方案3 | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |

## 最终推荐

### 如果轨道数量 < 30：推荐方案3
- 实现简单
- 对齐精确
- 用户体验好（可以看到所有轨道）

### 如果轨道数量 >= 30：推荐方案2
- 可以滚动，节省空间
- 对齐精度高（通过精确同步）
- 用户体验好

### 如果追求完美对齐：推荐方案1
- 同一坐标系，对齐最精确
- 但实现复杂度较高




